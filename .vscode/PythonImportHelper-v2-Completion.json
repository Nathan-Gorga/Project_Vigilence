[
    {
        "label": "_find_eog_events",
        "importPath": "mne.preprocessing.eog",
        "description": "mne.preprocessing.eog",
        "isExtraImport": true,
        "detail": "mne.preprocessing.eog",
        "documentation": {}
    },
    {
        "label": "TOLERANCE",
        "importPath": "include",
        "description": "include",
        "isExtraImport": true,
        "detail": "include",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "detectEOGEvents",
        "importPath": "Detection",
        "description": "Detection",
        "isExtraImport": true,
        "detail": "Detection",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "isExtraImport": true,
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "isExtraImport": true,
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "detectChannelsEOGEvents",
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "isExtraImport": true,
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "detectChannelsEOGEvents",
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "isExtraImport": true,
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "removeFalsePositives",
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "isExtraImport": true,
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "load_xdf",
        "importPath": "pyxdf",
        "description": "pyxdf",
        "isExtraImport": true,
        "detail": "pyxdf",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "printDetectedEOGs",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "isExtraImport": true,
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "batchTest",
        "importPath": "evaluation.Evaluation",
        "description": "evaluation.Evaluation",
        "isExtraImport": true,
        "detail": "evaluation.Evaluation",
        "documentation": {}
    },
    {
        "label": "isSameEvent",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def isSameEvent(x1 :int,x2 :int):\n    return (x1 - TOLERANCE) <= x2 <= (x1 + TOLERANCE)\ndef mergeEvents(event1 :int, event2 :int, channel :list[int]):\n    #create new event\n    newEvent = int(np.mean([event1,event2]))\n    #store old event index\n    leastEvent = event1 if event1 < event2 else event2\n    oldIndex = channel.index(leastEvent)\n    #remove old events\n    channel.remove(event1)",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "mergeEvents",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def mergeEvents(event1 :int, event2 :int, channel :list[int]):\n    #create new event\n    newEvent = int(np.mean([event1,event2]))\n    #store old event index\n    leastEvent = event1 if event1 < event2 else event2\n    oldIndex = channel.index(leastEvent)\n    #remove old events\n    channel.remove(event1)\n    channel.remove(event2)\n    #store new event at old event index",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "eventInChannel",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def eventInChannel(eventA :int, channelB: list[int]):\n    if len(channelB) == 0: return False\n    flag = False\n    previous = -1000 # should not be called the very first time so not a problem\n    # condition if channelB only has 1 event\n    if len(channelB) == 1 and isSameEvent(eventA,previous): return True\n    for eventB in channelB.copy():\n        if isSameEvent(eventA,eventB):        \n            if isSameEvent(eventA, previous):\n                channelB = mergeEvents(previous,eventB,channelB)",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "removeFalsePositives",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def removeFalsePositives(eog_events): \n    chA = eog_events[0]\n    chB = eog_events[1]\n    for event in chA.copy():\n        if not eventInChannel(event, chB):\n            chA.remove(event)\n    for event in chB.copy():\n        if not eventInChannel(event, chA):\n            chB.remove(event)\n    assert len(chA) == len(chB)",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "detectEOGEvents",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def detectEOGEvents(channel_data,sfreq):     \n    TOO_SHORT = 2048\n    method = \"fir\"\n    signal_length = len(channel_data) \n    if signal_length < TOO_SHORT:\n        method = \"iir\"\n    eog_events = _find_eog_events(\n        eog=channel_data,\n        ch_names=None,\n        event_id=998,",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "detectChannelsEOGEvents",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def detectChannelsEOGEvents(channels,sfreq):\n    ret = []\n    for channel_data in channels:\n        ret.append(detectEOGEvents([channel_data],sfreq))\n    return removeFalsePositives(ret)",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "dummy_signal",
        "kind": 2,
        "importPath": "detection.tDetectEOGEvents",
        "description": "detection.tDetectEOGEvents",
        "peekOfCode": "def dummy_signal():\n    # Un signal factice avec des \"blinks\" visibles\n    sfreq = 250  # Hz\n    import numpy as np\n    duration = 5  # 2 sec\n    n_samples = sfreq * duration\n    signal = [0.0] * n_samples\n    # Ajout de 3 blinks simulés\n    signal[100] = 5.0\n    signal[500] = 6.0",
        "detail": "detection.tDetectEOGEvents",
        "documentation": {}
    },
    {
        "label": "test_detect_eog_event_runs",
        "kind": 2,
        "importPath": "detection.tDetectEOGEvents",
        "description": "detection.tDetectEOGEvents",
        "peekOfCode": "def test_detect_eog_event_runs(dummy_signal):\n    signal, sfreq = dummy_signal\n    result = detectEOGEvents(signal, sfreq)\n    # Test que la fonction retourne une liste\n    assert isinstance(result, list)\n    # Test que tous les éléments sont des entiers\n    assert all(isinstance(x, int) for x in result)",
        "detail": "detection.tDetectEOGEvents",
        "documentation": {}
    },
    {
        "label": "test_all_events_match_within_tolerance",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_all_events_match_within_tolerance():\n    input_data = [[100, 200, 300], [104, 195, 296]]  # within ±BLINK_TIME\n    expected = [[100, 200, 300], [104, 195, 296]]\n    assert removeFalsePositives(input_data) == expected\ndef test_some_events_out_of_tolerance():\n    input_data = [[100, 200, 400], [100, 280, 400]]  # 280 not within ±BLINK_TIME of 200\n    expected = [[100, 400], [100, 400]]\n    assert removeFalsePositives(input_data) == expected\ndef test_no_events_within_tolerance():\n    input_data = [[100, 200], [300, 400]]",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "test_some_events_out_of_tolerance",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_some_events_out_of_tolerance():\n    input_data = [[100, 200, 400], [100, 280, 400]]  # 280 not within ±BLINK_TIME of 200\n    expected = [[100, 400], [100, 400]]\n    assert removeFalsePositives(input_data) == expected\ndef test_no_events_within_tolerance():\n    input_data = [[100, 200], [300, 400]]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_one_channel_empty():\n    input_data = [[100, 200], []]",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "test_no_events_within_tolerance",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_no_events_within_tolerance():\n    input_data = [[100, 200], [300, 400]]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_one_channel_empty():\n    input_data = [[100, 200], []]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_both_channels_empty():\n    input_data = [[], []]",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "test_one_channel_empty",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_one_channel_empty():\n    input_data = [[100, 200], []]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_both_channels_empty():\n    input_data = [[], []]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_duplicate_events_still_match():\n    input_data = [[100, 200, 200], [204, 100]]  # 204 ≈ 200",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "test_both_channels_empty",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_both_channels_empty():\n    input_data = [[], []]\n    expected = [[], []]\n    assert removeFalsePositives(input_data) == expected\ndef test_duplicate_events_still_match():\n    input_data = [[100, 200, 200], [204, 100]]  # 204 ≈ 200\n    expected = [[100, 200, 200], [204, 100]]\n    assert removeFalsePositives(input_data) == expected",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "test_duplicate_events_still_match",
        "kind": 2,
        "importPath": "detection.tRemoveFalsePositives",
        "description": "detection.tRemoveFalsePositives",
        "peekOfCode": "def test_duplicate_events_still_match():\n    input_data = [[100, 200, 200], [204, 100]]  # 204 ≈ 200\n    expected = [[100, 200, 200], [204, 100]]\n    assert removeFalsePositives(input_data) == expected",
        "detail": "detection.tRemoveFalsePositives",
        "documentation": {}
    },
    {
        "label": "runTest",
        "kind": 2,
        "importPath": "evaluation.Evaluation",
        "description": "evaluation.Evaluation",
        "peekOfCode": "def runTest(filepath :str):\n    selected_channels: list[int] = [1,3]\n    [ channels, sfreq ] = extractChannelsFromXdf(filepath,selected_channels, extract_sfreq=True)\n    return detectChannelsEOGEvents(channels,sfreq)\ndef oneTest(json_path: str) -> bool:\n    with open(json_path, \"r\") as f:\n        test_data = json.load(f)\n    filepath = test_data[\"filepath\"]\n    expected_outcome = test_data[\"expected\"][\"outcome\"]  # \"TRUE_POSITIVE\" ou \"TRUE_NEGATIVE\"\n    expected_blinks = test_data[\"expected\"][\"blinks\"]",
        "detail": "evaluation.Evaluation",
        "documentation": {}
    },
    {
        "label": "oneTest",
        "kind": 2,
        "importPath": "evaluation.Evaluation",
        "description": "evaluation.Evaluation",
        "peekOfCode": "def oneTest(json_path: str) -> bool:\n    with open(json_path, \"r\") as f:\n        test_data = json.load(f)\n    filepath = test_data[\"filepath\"]\n    expected_outcome = test_data[\"expected\"][\"outcome\"]  # \"TRUE_POSITIVE\" ou \"TRUE_NEGATIVE\"\n    expected_blinks = test_data[\"expected\"][\"blinks\"]\n    # Exécution de l'algorithme\n    events = runTest(filepath)\n    num_events = len(events[0])\n    # Comparaison avec la vérité terrain",
        "detail": "evaluation.Evaluation",
        "documentation": {}
    },
    {
        "label": "batchTest",
        "kind": 2,
        "importPath": "evaluation.Evaluation",
        "description": "evaluation.Evaluation",
        "peekOfCode": "def batchTest(json_folder: str):\n    folder = Path(json_folder)\n    json_files = list(folder.glob(\"*.json\"))\n    successes = 0\n    failures = 0\n    for json_file in json_files:\n        if oneTest(str(json_file)):\n            successes += 1\n        else:\n            failures += 1",
        "detail": "evaluation.Evaluation",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "kind": 2,
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "peekOfCode": "def extractChannelsFromXdf(filepath:str, selected_channels:list[int], extract_sfreq=False):\n    try :\n        dictStreams,_  = load_xdf(filepath)\n    except Exception:\n        raise FileNotFoundError(f\"file : {filepath} does not exist\")\n    stream = dictStreams[0]['time_series']\n    if extract_sfreq:\n        sfreq = float(dictStreams[0]['info']['nominal_srate'][0])\n    extracted_data = []\n    size = len(stream)",
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_single_channel",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_extract_single_channel(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0])\n    assert result == [\n        [1.0, 1.1, 1.2]\n    ]\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_extract_multiple_channels(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0, 2])",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "test_extract_multiple_channels",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_extract_multiple_channels(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0, 2])\n    assert result == [\n        [1.0, 1.1, 1.2],\n        [3.0, 3.1, 3.2]\n    ]\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_extract_with_sampling_rate(mock_load):\n    from Extraction import extractChannelsFromXdf",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "test_extract_with_sampling_rate",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_extract_with_sampling_rate(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [1], extract_sfreq=True)\n    assert result[0] == [[2.0, 2.1, 2.2]]\n    assert result[1] == 250\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_invalid_channel_index_high(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [5])",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_high",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_invalid_channel_index_high(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [5])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_invalid_channel_index_negative(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [-1])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_negative",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_invalid_channel_index_negative(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [-1])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_empty_channel_list(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [])\n    assert result == []",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "test_empty_channel_list",
        "kind": 2,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "def test_empty_channel_list(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [])\n    assert result == []",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "mock_xdf_data",
        "kind": 5,
        "importPath": "extraction.tExtractDataFromXdf",
        "description": "extraction.tExtractDataFromXdf",
        "peekOfCode": "mock_xdf_data = (\n    [{\n        'time_series': [\n            [1.0, 2.0, 3.0],\n            [1.1, 2.1, 3.1],\n            [1.2, 2.2, 3.2],\n        ],\n        'info': {\n            'nominal_srate': ['250.0']\n        }",
        "detail": "extraction.tExtractDataFromXdf",
        "documentation": {}
    },
    {
        "label": "dummy_channels",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def dummy_channels():\n    return [\n        [0.1 * i for i in range(10)], \n        [0.2 * i for i in range(10)]\n    ]\n@pytest.fixture\ndef dummy_eog_events():\n    return [2, 5, 8]\n# Test printChannels runs without error\ndef test_print_channels_runs(dummy_channels):",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "dummy_eog_events",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def dummy_eog_events():\n    return [2, 5, 8]\n# Test printChannels runs without error\ndef test_print_channels_runs(dummy_channels):\n    axs = printChannels(dummy_channels)\n    assert len(axs) == 2  # We expect 2 subplots for 2 channels\n# Test printDetectedEOGs adds lines\ndef test_print_detected_eogs_runs(dummy_channels, dummy_eog_events):\n    axs = printDetectedEOGs(dummy_channels, dummy_eog_events)\n    assert len(axs) == 2  # Again, 2 channels means 2 subplots",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "test_print_channels_runs",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def test_print_channels_runs(dummy_channels):\n    axs = printChannels(dummy_channels)\n    assert len(axs) == 2  # We expect 2 subplots for 2 channels\n# Test printDetectedEOGs adds lines\ndef test_print_detected_eogs_runs(dummy_channels, dummy_eog_events):\n    axs = printDetectedEOGs(dummy_channels, dummy_eog_events)\n    assert len(axs) == 2  # Again, 2 channels means 2 subplots\n# Test printData in channelOnly mode\ndef test_print_data_channel_only(dummy_channels):\n    with patch(\"matplotlib.pyplot.show\"):",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "test_print_detected_eogs_runs",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def test_print_detected_eogs_runs(dummy_channels, dummy_eog_events):\n    axs = printDetectedEOGs(dummy_channels, dummy_eog_events)\n    assert len(axs) == 2  # Again, 2 channels means 2 subplots\n# Test printData in channelOnly mode\ndef test_print_data_channel_only(dummy_channels):\n    with patch(\"matplotlib.pyplot.show\"):\n        printData(dummy_channels, select_channels=[0, 1], viewType=\"channel_only\")\n# Test printData in detected_eogs mode\ndef test_print_data_detected_eogs(dummy_channels, dummy_eog_events):\n    with patch(\"matplotlib.pyplot.show\"):",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "test_print_data_channel_only",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def test_print_data_channel_only(dummy_channels):\n    with patch(\"matplotlib.pyplot.show\"):\n        printData(dummy_channels, select_channels=[0, 1], viewType=\"channel_only\")\n# Test printData in detected_eogs mode\ndef test_print_data_detected_eogs(dummy_channels, dummy_eog_events):\n    with patch(\"matplotlib.pyplot.show\"):\n        printData(\n            dummy_channels,\n            select_channels=[0, 1],\n            viewType=\"detected_eogs\",",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "test_print_data_detected_eogs",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def test_print_data_detected_eogs(dummy_channels, dummy_eog_events):\n    with patch(\"matplotlib.pyplot.show\"):\n        printData(\n            dummy_channels,\n            select_channels=[0, 1],\n            viewType=\"detected_eogs\",\n            eog_events=dummy_eog_events\n        )\n# Test printData with invalid viewType\ndef test_print_data_invalid_viewtype(dummy_channels):",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "test_print_data_invalid_viewtype",
        "kind": 2,
        "importPath": "visualize.tPrintData",
        "description": "visualize.tPrintData",
        "peekOfCode": "def test_print_data_invalid_viewtype(dummy_channels):\n    with patch(\"matplotlib.pyplot.show\"):\n        with pytest.raises(ValueError):\n            printData(dummy_channels, select_channels=[0], viewType=\"invalid\")",
        "detail": "visualize.tPrintData",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printChannels(channels :list[list[float]]):\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].scatter(range(len(data)), data, color=color[i % len(color)],s=10)\n        axs[i].set_ylabel(f\"Channel {i+1}\")",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printDetectedEOGs",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printDetectedEOGs(channels : list[list[float]], eog_events):\n    assert len(channels) == len(eog_events)\n    axs = printChannels(channels)\n    sizeChannels = len(channels)\n    sizeColor = len(color)\n    for i in range(sizeChannels):\n        sizeEvents = len(eog_events[i])\n        for j in range(sizeEvents):\n            axs[i].axvline(x=eog_events[i][j], color=color[((i+1)%sizeColor)] , linestyle='--', linewidth=2)\n    return axs",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printData(\n    channels :list[list[float]], \n    select_channels, \n    viewType :str=\"channel_only\", \n    thresh=None,\n    eog_events=None\n    ):\n    viewTypes = [\"channel_only\", \"detected_eogs\"]    \n    if viewType not in viewTypes:\n        raise ValueError(f\"ViewType : {viewType} does not exist, please choose one from the list : {viewTypes}\")",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "color = [\"blue\", \"green\", \"red\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\ndef printChannels(channels :list[list[float]]):\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].scatter(range(len(data)), data, color=color[i % len(color)],s=10)",
        "detail": "visualize.Visualize",
        "documentation": {}
    }
]