[
    {
        "label": "load_xdf",
        "importPath": "pyxdf",
        "description": "pyxdf",
        "isExtraImport": true,
        "detail": "pyxdf",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "isExtraImport": true,
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "isExtraImport": true,
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "kind": 2,
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "peekOfCode": "def extractChannelsFromXdf(filepath:str, selected_channels:list[int]) -> list[list[float]]:\n    try :\n        dictStreams,_  = load_xdf(filepath)\n    except Exception:\n        raise FileNotFoundError(f\"file : {filepath} does not exist\")\n    stream = dictStreams[0]['time_series']\n    extracted_data = []\n    size = len(stream)\n    for ch in selected_channels:\n        if ch < 0 or ch >= size : raise IndexError(f\"stream only has {size} channels, index was {ch}\")",
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "mock_xdf",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def mock_xdf(monkeypatch):\n    fake_load_xdf = MagicMock(return_value=([\n        {'time_series': mock_time_series}\n    ], {}))\n    monkeypatch.setattr(\"pyxdf.load_xdf\", fake_load_xdf)\n# ---- Tests ----\ndef test_extract_single_channel(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [1])\n    assert result == [[0.2, 0.5, 0.8]]",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_single_channel",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_single_channel(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [1])\n    assert result == [[0.2, 0.5, 0.8]]\ndef test_extract_multiple_channels(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [0, 2])\n    assert result == [\n        [0.1, 0.4, 0.7],\n        [0.3, 0.6, 0.9]",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_multiple_channels",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_multiple_channels(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [0, 2])\n    assert result == [\n        [0.1, 0.4, 0.7],\n        [0.3, 0.6, 0.9]\n    ]\ndef test_invalid_channel_index_high(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"stream only has 3 channels\"):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_high",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_high(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"stream only has 3 channels\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [3])\ndef test_invalid_channel_index_negative(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"index was -1\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [-1])\ndef test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_negative",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_negative(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"index was -1\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [-1])\ndef test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [])\n    assert result == []\ndef test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_empty_channel_list",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [])\n    assert result == []\ndef test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):\n        raise FileNotFoundError(\"file : nonexistent_file.xdf does not exist\")\n    monkeypatch.setattr(\"Extraction.load_xdf\", fake_load_xdf_fail)  \n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(FileNotFoundError):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_file_load_failure",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):\n        raise FileNotFoundError(\"file : nonexistent_file.xdf does not exist\")\n    monkeypatch.setattr(\"Extraction.load_xdf\", fake_load_xdf_fail)  \n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(FileNotFoundError):\n        extractChannelsFromXdf(\"nonexistent_file.xdf\", [0])",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "mock_time_series",
        "kind": 5,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "mock_time_series = [\n    [0.1, 0.2, 0.3],\n    [0.4, 0.5, 0.6],\n    [0.7, 0.8, 0.9],\n]  # 3 samples, 3 channels\n# ---- Fixtures and Helpers ----\n@pytest.fixture\ndef mock_xdf(monkeypatch):\n    fake_load_xdf = MagicMock(return_value=([\n        {'time_series': mock_time_series}",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "sample_channels",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def sample_channels(n_channels=3, length=10):\n    return [[float(i + j) for j in range(length)] for i in range(n_channels)]\ndef test_print_channels_single_channel(monkeypatch):\n    channels = sample_channels(1)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        ax = MagicMock()\n        mock_subplots.return_value = (fig, ax)\n        printChannels(channels)\n        mock_subplots.assert_called_once_with(1, 1, figsize=(10, 3), sharex=True)",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_channels_single_channel",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_channels_single_channel(monkeypatch):\n    channels = sample_channels(1)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        ax = MagicMock()\n        mock_subplots.return_value = (fig, ax)\n        printChannels(channels)\n        mock_subplots.assert_called_once_with(1, 1, figsize=(10, 3), sharex=True)\n        assert ax.plot.called\n        assert ax.scatter.called",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_channels_multiple",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_channels_multiple(monkeypatch):\n    channels = sample_channels(4)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        axs = [MagicMock() for _ in range(4)]\n        mock_subplots.return_value = (fig, axs)\n        printChannels(channels)\n        assert mock_subplots.call_count == 1\n        for ax in axs:\n            assert ax.plot.called",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_data_channelOnly",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_data_channelOnly(monkeypatch):\n    channels = sample_channels(3)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots, \\\n         patch(\"matplotlib.pyplot.tight_layout\") as mock_layout, \\\n         patch(\"matplotlib.pyplot.show\") as mock_show:\n        fig = MagicMock()\n        axs = [MagicMock() for _ in range(2)]\n        mock_subplots.return_value = (fig, axs)\n        printData(channels, [0, 2], viewType=\"channelOnly\")\n        mock_layout.assert_called_once()",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_data_invalid_index",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_data_invalid_index():\n    channels = sample_channels(2)\n    with pytest.raises(IndexError):\n        printData(channels, [5], viewType=\"channelOnly\")",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printChannels(channels :list[list[float]]):\n    color = [\"blue\", \"green\", \"red\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].scatter(range(len(data)), data, color=color[i % len(color)])",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printData(\n    channels :list[list[float]], \n    select_channels, \n    viewType :str=\"channelOnly\", \n    thresh=None\n    ):\n    send_channels = []\n    for i in select_channels:\n        send_channels.append(channels[i])\n    match viewType:",
        "detail": "visualize.Visualize",
        "documentation": {}
    }
]