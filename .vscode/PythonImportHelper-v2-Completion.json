[
    {
        "label": "_find_eog_events",
        "importPath": "mne.preprocessing.eog",
        "description": "mne.preprocessing.eog",
        "isExtraImport": true,
        "detail": "mne.preprocessing.eog",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "detectEOGEvent",
        "importPath": "Detection",
        "description": "Detection",
        "isExtraImport": true,
        "detail": "Detection",
        "documentation": {}
    },
    {
        "label": "load_xdf",
        "importPath": "pyxdf",
        "description": "pyxdf",
        "isExtraImport": true,
        "detail": "pyxdf",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "Visualize",
        "description": "Visualize",
        "isExtraImport": true,
        "detail": "Visualize",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "isExtraImport": true,
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "isExtraImport": true,
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "detectEOGEvent",
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "isExtraImport": true,
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "detectEOGEvent",
        "kind": 2,
        "importPath": "detection.Detection",
        "description": "detection.Detection",
        "peekOfCode": "def detectEOGEvent(channel_data,sfreq): \n    filter_length = f\"{len(channel_data)*3}s\" \n    eog_events = _find_eog_events(\n        eog=channel_data,\n        ch_names=None,\n        event_id=998,\n        l_freq=1,\n        h_freq=10,\n        sampling_rate=sfreq,\n        first_samp=0,",
        "detail": "detection.Detection",
        "documentation": {}
    },
    {
        "label": "dummy_signal",
        "kind": 2,
        "importPath": "detection.tDetection",
        "description": "detection.tDetection",
        "peekOfCode": "def dummy_signal():\n    # Un signal factice avec des \"blinks\" visibles\n    sfreq = 250  # Hz\n    import numpy as np\n    duration = 5  # 2 sec\n    n_samples = sfreq * duration\n    signal = [0.0] * n_samples\n    # Ajout de 3 blinks simulés\n    signal[100] = 5.0\n    signal[500] = 6.0",
        "detail": "detection.tDetection",
        "documentation": {}
    },
    {
        "label": "test_detect_eog_event_runs",
        "kind": 2,
        "importPath": "detection.tDetection",
        "description": "detection.tDetection",
        "peekOfCode": "def test_detect_eog_event_runs(dummy_signal):\n    signal, sfreq = dummy_signal\n    result = detectEOGEvent(signal, sfreq)\n    # Test que la fonction retourne une liste\n    assert isinstance(result, list)\n    # Test que tous les éléments sont des entiers\n    assert all(isinstance(x, int) for x in result)",
        "detail": "detection.tDetection",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "kind": 2,
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "peekOfCode": "def extractChannelsFromXdf(filepath:str, selected_channels:list[int], extract_sfreq=False):\n    try :\n        dictStreams,_  = load_xdf(filepath)\n    except Exception:\n        raise FileNotFoundError(f\"file : {filepath} does not exist\")\n    stream = dictStreams[0]['time_series']\n    if extract_sfreq:\n        sfreq = float(dictStreams[0]['info']['nominal_srate'][0])\n    extracted_data = []\n    size = len(stream)",
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_single_channel",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_single_channel(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0])\n    assert result == [\n        [1.0, 1.1, 1.2]\n    ]\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_extract_multiple_channels(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0, 2])",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_multiple_channels",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_multiple_channels(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [0, 2])\n    assert result == [\n        [1.0, 1.1, 1.2],\n        [3.0, 3.1, 3.2]\n    ]\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_extract_with_sampling_rate(mock_load):\n    from Extraction import extractChannelsFromXdf",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_with_sampling_rate",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_with_sampling_rate(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [1], extract_sfreq=True)\n    assert result[0] == [[2.0, 2.1, 2.2]]\n    assert result[1] == 250\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_invalid_channel_index_high(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [5])",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_high",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_high(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [5])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_invalid_channel_index_negative(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [-1])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_negative",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_negative(mock_load):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError):\n        extractChannelsFromXdf(\"dummy.xdf\", [-1])\n@patch(\"pyxdf.load_xdf\", return_value=mock_xdf_data)\ndef test_empty_channel_list(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [])\n    assert result == []",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_empty_channel_list",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_empty_channel_list(mock_load):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"dummy.xdf\", [])\n    assert result == []",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "mock_xdf_data",
        "kind": 5,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "mock_xdf_data = (\n    [{\n        'time_series': [\n            [1.0, 2.0, 3.0],\n            [1.1, 2.1, 3.1],\n            [1.2, 2.2, 3.2],\n        ],\n        'info': {\n            'nominal_srate': ['250.0']\n        }",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "sample_channels",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def sample_channels(n_channels=3, length=10):\n    return [[float(i + j) for j in range(length)] for i in range(n_channels)]\ndef test_print_channels_single_channel(monkeypatch):\n    channels = sample_channels(1)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        ax = MagicMock()\n        mock_subplots.return_value = (fig, ax)\n        printChannels(channels)\n        mock_subplots.assert_called_once_with(1, 1, figsize=(10, 3), sharex=True)",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_channels_single_channel",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_channels_single_channel(monkeypatch):\n    channels = sample_channels(1)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        ax = MagicMock()\n        mock_subplots.return_value = (fig, ax)\n        printChannels(channels)\n        mock_subplots.assert_called_once_with(1, 1, figsize=(10, 3), sharex=True)\n        assert ax.plot.called\n        assert ax.scatter.called",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_channels_multiple",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_channels_multiple(monkeypatch):\n    channels = sample_channels(4)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots:\n        fig = MagicMock()\n        axs = [MagicMock() for _ in range(4)]\n        mock_subplots.return_value = (fig, axs)\n        printChannels(channels)\n        assert mock_subplots.call_count == 1\n        for ax in axs:\n            assert ax.plot.called",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_data_channelOnly",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_data_channelOnly(monkeypatch):\n    channels = sample_channels(3)\n    with patch(\"matplotlib.pyplot.subplots\") as mock_subplots, \\\n         patch(\"matplotlib.pyplot.tight_layout\") as mock_layout, \\\n         patch(\"matplotlib.pyplot.show\") as mock_show:\n        fig = MagicMock()\n        axs = [MagicMock() for _ in range(2)]\n        mock_subplots.return_value = (fig, axs)\n        printData(channels, [0, 2], viewType=\"channelOnly\")\n        mock_layout.assert_called_once()",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "test_print_data_invalid_index",
        "kind": 2,
        "importPath": "visualize.tVisualize",
        "description": "visualize.tVisualize",
        "peekOfCode": "def test_print_data_invalid_index():\n    channels = sample_channels(2)\n    with pytest.raises(IndexError):\n        printData(channels, [5], viewType=\"channelOnly\")",
        "detail": "visualize.tVisualize",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printChannels(channels :list[list[float]]):\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].scatter(range(len(data)), data, color=color[i % len(color)],s=10)\n        axs[i].set_ylabel(f\"Channel {i+1}\")",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printDetectedEOGs",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printDetectedEOGs(channels : list[list[float]], eog_events):\n    axs = printChannels(channels)\n    sizeChannels = len(channels)\n    sizeEvents = len(eog_events)\n    sizeColor = len(color)\n    for i in range(sizeChannels):\n        for j in range(sizeEvents):\n            axs[i].axvline(x=eog_events[j], color=color[((i+1)%sizeColor)] , linestyle='--', linewidth=2)\n    return axs\ndef printData(",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printData(\n    channels :list[list[float]], \n    select_channels, \n    viewType :str=\"channelOnly\", \n    thresh=None,\n    eog_events=None\n    ):\n    send_channels = []\n    for i in select_channels:\n        send_channels.append(channels[i])",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "color = [\"blue\", \"green\", \"red\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\ndef printChannels(channels :list[list[float]]):\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].scatter(range(len(data)), data, color=color[i % len(color)],s=10)",
        "detail": "visualize.Visualize",
        "documentation": {}
    }
]