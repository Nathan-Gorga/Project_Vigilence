[
    {
        "label": "load_xdf",
        "importPath": "pyxdf",
        "description": "pyxdf",
        "isExtraImport": true,
        "detail": "pyxdf",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "isExtraImport": true,
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "printData",
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "isExtraImport": true,
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "extractChannelsFromXdf",
        "kind": 2,
        "importPath": "extraction.Extraction",
        "description": "extraction.Extraction",
        "peekOfCode": "def extractChannelsFromXdf(filepath:str, selected_channels:list[int]) -> list[list[float]]:\n    try :\n        dictStreams,_  = load_xdf(filepath)\n    except Exception:\n        raise FileNotFoundError(f\"file : {filepath} does not exist\")\n    stream = dictStreams[0]['time_series']\n    extracted_data = []\n    size = len(stream)\n    for ch in selected_channels:\n        if ch < 0 or ch >= size : raise IndexError(f\"stream only has {size} channels, index was {ch}\")",
        "detail": "extraction.Extraction",
        "documentation": {}
    },
    {
        "label": "mock_xdf",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def mock_xdf(monkeypatch):\n    fake_load_xdf = MagicMock(return_value=([\n        {'time_series': mock_time_series}\n    ], {}))\n    monkeypatch.setattr(\"pyxdf.load_xdf\", fake_load_xdf)\n# ---- Tests ----\ndef test_extract_single_channel(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [1])\n    assert result == [[0.2, 0.5, 0.8]]",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_single_channel",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_single_channel(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [1])\n    assert result == [[0.2, 0.5, 0.8]]\ndef test_extract_multiple_channels(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [0, 2])\n    assert result == [\n        [0.1, 0.4, 0.7],\n        [0.3, 0.6, 0.9]",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_extract_multiple_channels",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_extract_multiple_channels(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [0, 2])\n    assert result == [\n        [0.1, 0.4, 0.7],\n        [0.3, 0.6, 0.9]\n    ]\ndef test_invalid_channel_index_high(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"stream only has 3 channels\"):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_high",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_high(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"stream only has 3 channels\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [3])\ndef test_invalid_channel_index_negative(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"index was -1\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [-1])\ndef test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_invalid_channel_index_negative",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_invalid_channel_index_negative(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(IndexError, match=r\"index was -1\"):\n        extractChannelsFromXdf(\"fake_path.xdf\", [-1])\ndef test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [])\n    assert result == []\ndef test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_empty_channel_list",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_empty_channel_list(mock_xdf):\n    from Extraction import extractChannelsFromXdf\n    result = extractChannelsFromXdf(\"fake_path.xdf\", [])\n    assert result == []\ndef test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):\n        raise FileNotFoundError(\"file : nonexistent_file.xdf does not exist\")\n    monkeypatch.setattr(\"Extraction.load_xdf\", fake_load_xdf_fail)  \n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(FileNotFoundError):",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "test_file_load_failure",
        "kind": 2,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "def test_file_load_failure(monkeypatch):\n    def fake_load_xdf_fail(*args, **kwargs):\n        raise FileNotFoundError(\"file : nonexistent_file.xdf does not exist\")\n    monkeypatch.setattr(\"Extraction.load_xdf\", fake_load_xdf_fail)  \n    from Extraction import extractChannelsFromXdf\n    with pytest.raises(FileNotFoundError):\n        extractChannelsFromXdf(\"nonexistent_file.xdf\", [0])",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "mock_time_series",
        "kind": 5,
        "importPath": "extraction.tExtraction",
        "description": "extraction.tExtraction",
        "peekOfCode": "mock_time_series = [\n    [0.1, 0.2, 0.3],\n    [0.4, 0.5, 0.6],\n    [0.7, 0.8, 0.9],\n]  # 3 samples, 3 channels\n# ---- Fixtures and Helpers ----\n@pytest.fixture\ndef mock_xdf(monkeypatch):\n    fake_load_xdf = MagicMock(return_value=([\n        {'time_series': mock_time_series}",
        "detail": "extraction.tExtraction",
        "documentation": {}
    },
    {
        "label": "printChannels",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printChannels(channels :list[list[float]]):\n    color = [\"blue\", \"green\", \"red\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\n    num_channels = len(channels)\n    _, axs = plt.subplots(num_channels, 1, figsize=(10, 3 * num_channels), sharex=True)\n    # If only 1 channel, axs is not a list\n    if num_channels == 1:\n        axs = [axs]\n    for i, data in enumerate(channels):\n        axs[i].plot(range(len(data)), data, color=color[i % len(color)])\n        axs[i].set_ylabel(f\"Channel {i+1}\")",
        "detail": "visualize.Visualize",
        "documentation": {}
    },
    {
        "label": "printData",
        "kind": 2,
        "importPath": "visualize.Visualize",
        "description": "visualize.Visualize",
        "peekOfCode": "def printData(\n    channels :list[list[float]], \n    select_channels, \n    viewType :str=\"channelOnly\", \n    thresh=None\n    ):\n    send_channels = []\n    for i in select_channels:\n        send_channels.append(channels[i])\n    match viewType:",
        "detail": "visualize.Visualize",
        "documentation": {}
    }
]